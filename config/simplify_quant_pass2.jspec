// -*- tab-width:2 ; indent-tabs-mode:nil -*-

class simplify_quant_pass2 {

  int e1,e2,e3,e4,e5,e6,e7,e8;
  boolean b1,b2,b3,b4;
  resource r1,r2;
  int i,j,k;
  
  int ar[];
  
  axiom aunitr { e1+0 == e1 }
  axiom aunitl { 0+e1 == e1 }
  
  axiom munitr { e1*1 == e1 }
  axiom munitl { 1*e1 == e1 }
  
  axiom I2 {
    0 * e1 == 0
  }
  axiom I3 {
    e1 * 0 == 0
  }

  // simplify x*a+b index.
  // PROBLEM: this is wrong if e3 < 0!
  axiom simplify_linear_ab {
    (\forall* int i;( i \memberof [ e1 .. e2 )) ; Perm( ar [ i*(e3!i) +(e4!i) ] , (e5!i) ))
     ==
    (\forall* int i;( i \memberof [ e1*e3+e4 .. e2*e3+e4 )) && (i - e4) % e3 == 0 ; Perm( ar [ i ] , e5 ))
  }
  
  // completion for b==0.
  axiom simplify_linear_a {
    (\forall* int i;( i \memberof [ e1 .. e2 )) ; Perm( ar [ i*(e3!i)] , (e5!i) ))
     ==
    (\forall* int i;( i \memberof [ e1*e3 .. e2*e3 )) && i % e3 == 0 ; Perm( ar [ i ] , e5 ))
  }
  
  // completion for a==1.
  axiom simplify_linear_b {
    (\forall* int i;( i \memberof [ e1 .. e2 )) ; Perm( ar [ i +(e4!i) ] , (e5!i) ))
     ==
    (\forall* int i;( i \memberof [ e1+e4 .. e2+e4 )) ; Perm( ar [ i ] , e5 ))
  }
  
  axiom simplify_shift_1 {
    (\forall* int i; b1 ; Perm( ar [ (e1!i) + i ] , (e2!i) ))
      ==
    (\forall* int k_fresh ; (\let int i=k_fresh-e1;b1) ; Perm( ar [ k_fresh ] , e2 ))
  }
  
  axiom simplify_shift_2 {
    (\forall* int i; b1 ; Perm( ar [ i + (e1!i) ] , (e2!i) ))
      ==
    (\forall* int k_fresh ; (\let int i=k_fresh-e1;b1) ; Perm( ar [ k_fresh ] , e2 ))
  }
  
  axiom simplify_shift_3 {
    (\forall* int i; b1 ; Perm( ar [ i - (e1!i) ] , (e2!i) ))
      ==
    (\forall* int k_fresh ; (\let int i=k_fresh+e1;b1) ; Perm( ar [ k_fresh ] , e2 ))
  }
  
  axiom simplify_shift_scale_1 {
    (\forall* int i; b1 ; Perm( ar [ (e1!i) + i * (e2!i) ] , (e3!i) ))
      ==
    (\forall* int k_fresh ; (\let int i=(k_fresh/e2)-e1;b1) && k_fresh % e2 == 0; Perm( ar [ k_fresh ] , e3 ))
  }


  axiom unfold_2 {
    (\forall* int i; ( i \memberof ([ 0 .. 2 ))) ; r1)
    ==
    (\let int i=0; r1) ** (\let int i=1; r1)
  }

}



field parent : Ref
field rank : Int

predicate uf_bank(b:Set[Ref])
{ (forall l:Ref :: {l in b} l in b ==>
    acc(l.parent) && acc(l.rank) && 0 <= l.rank) &&
  (forall l:Ref :: {l.parent} l in b && l.parent != null ==>
    l.parent in b && l.parent.rank > l.rank)
}

method bad(b:Set[Ref],l:Ref)
  requires uf_bank(b)
  requires l in b
  ensures false
{
  unfold uf_bank(b);
  fold uf_bank(b);
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert
    let n == (unfolding uf_bank(b) in l.rank) in
    n > n
}

method veryBad()
  ensures false
{
  var l : Ref;
  l := new(parent,rank);
  l.parent := null;
  l.rank := 0;
  //:: UnexpectedOutput(fold.failed:insufficient.permission, /carbon/issue/237/)
  fold uf_bank(Set(l));
  bad(Set(l),l);
}


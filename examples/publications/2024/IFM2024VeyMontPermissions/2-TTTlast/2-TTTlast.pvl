inline resource turnInvariant(Player p, Player q) =
  ([1\2]p.boardPerm()) **
  ([1\2]q.boardPerm()) **
  p.equalBoard(q)
  ;

inline resource state(Player p, Player other, boolean withBoardPerm) =
    (withBoardPerm ==> ([1\2]p.boardPerm())) **
    Perm(p.move, 1) ** p.move != null ** p.move.state() ** Perm(p.turn, 1) **
    Perm(p.myMark, 1\2) ** (p.myMark == 0 || p.myMark == 1) **
    ([1\4]p.returnerBound(other));

choreography Main() {
  endpoint p1 = Player(0, true);
  endpoint p2 = Player(1, false, p1);

  requires (\endpoint p1; state(p1, p2, true)) ** (\endpoint p2; state(p2, p1, true));
  requires p1.emptyBoard() ** p2.emptyBoard();
  requires (\endpoint p1; p1.turn ==>
      turnInvariant(p1, p2) ** ([1\2]p1.returnerBound(p2)) ** p1.returnerMark());
  requires (\endpoint p2; p2.turn ==>
      turnInvariant(p1, p2) ** ([1\2]p2.returnerBound(p1)) ** p2.returnerMark());
  requires (\chor p1.turn != p2.turn);
  ensures (\endpoint p1; state(p1, p2, true)) ** (\endpoint p2; state(p2, p1, true));
  ensures p1.gameFinished() && p2.gameFinished();
  ensures (\endpoint p1; ([1\2]p1.returnerMark()) **
    (p1.returner.mark == p1.myMark ==> turnInvariant(p1, p2)));
  ensures (\endpoint p2; ([1\2]p2.returnerMark()) **
    (p2.returner.mark == p2.myMark ==> turnInvariant(p1, p2)));
  run {
    loop_invariant (\endpoint p1; state(p1, p2, true)) ** (\endpoint p2; state(p2, p1, true));
    loop_invariant (\chor p1.turn != p2.turn);
    loop_invariant (\endpoint p1; p1.turn && !p1.gameFinished() ==>
      turnInvariant(p1, p2) **
      ([1\2]p1.returnerBound(p2)) **
      p1.returnerMark());
    loop_invariant (\endpoint p2; p2.turn && !p2.gameFinished() ==>
      turnInvariant(p2, p1) **
      ([1\2]p2.returnerBound(p1)) **
      p2.returnerMark());
    loop_invariant (\endpoint p1; p1.gameFinished() ==>
      ([1\2]p1.returnerMark()) **
      (p1.returner.mark == p1.myMark ==> turnInvariant(p1, p2)));
    loop_invariant (\endpoint p2; p2.gameFinished() ==>
      ([1\2]p2.returnerMark()) **
      (p2.returner.mark == p2.myMark ==> turnInvariant(p2, p1)));
    while (!p1.gameFinished() && !p2.gameFinished()) {
      if (p1.turn && !p2.turn) {
        p1.createNewMove();
        p1.doMove();
        if (p1.gameFinished()) {
          p1.returner.mark := 1 - p1.myMark;
          assert (\chor p1.returner.mark != p1.myMark);
        }
        channel_invariant
          \msg.state() **
          ([1\2]\sender.boardPerm()) ** ([1\2]\receiver.boardPerm()) **
          \sender.oneMoveAheadOf(\msg, \receiver) **
          ([1\2]\sender.returnerBound(\receiver)) **
          ([1\2]\sender.returnerMark()) **
          (!\sender.gameFinished() ==> ([1\2]\sender.returnerMark()));
        communicate p2.move <- p1.move.copy();
        p2.doMove();
        assert (\endpoint p2; p2.equalBoard(p1));
        assert (\endpoint p2; !p1.gameFinished() == !p2.gameFinished());
      } else {
        p2.createNewMove();
        p2.doMove();
        if (p2.gameFinished()) {
          p2.returner.mark := 1 - p2.myMark;
        }
        channel_invariant
          \msg.state() **
          ([1\2]\sender.boardPerm()) ** ([1\2]\receiver.boardPerm()) **
          \sender.oneMoveAheadOf(\msg, \receiver) **
          ([1\2]\sender.returnerBound(\receiver)) **
          ([1\2]\sender.returnerMark()) **
          (!\sender.gameFinished() ==> ([1\2]\sender.returnerMark()));
        communicate p1.move <- p2.move.copy();
        p1.doMove();
        assert (\endpoint p1; p1.equalBoard(p2));
        assert (\endpoint p1; !p1.gameFinished() == !p2.gameFinished());
      }
      p1.turn := !p1.turn;
      p2.turn := !p2.turn;
      // Assumption required for shortcoming in backend. Can be removed after implementing the lightweight encoding.

      // assume (\chor p1.gameFinished() == p2.gameFinished());
    }
    // assume (\chor p1.gameFinished() == p2.gameFinished());

    p1.finish();
    p2.finish();
  }
}

// -*- tab-width:2 ; indent-tabs-mode:nil -*-

//:: cases ColoredTiles
//:: tools silicon
//:: suite medium problem-fail
// Doesn't verify because of a bug:
// https://github.com/viperproject/silicon/issues/537
// The failing loop invariant succeeds when verified with silicon master
//:: verdict Fail

adt Int {
    pure int pred(int i);
    axiom (\forall int i; pred(i) == i - 1);
}

class ColoredTiles {

  pure boolean validSequence(seq<boolean> s, int n)
   = (s.size == n)
   && (\forall int i; 0 <= i && i < n; {: s[i] :} ==>
            (i >= 2            && s[i-2] && s[i-1])
         || (i >= 1 && i < n-1 && s[i-1] && s[i+1])
         || (i < n - 2        && s[i+1] && s[i+2])
      );
  
  pure boolean uniqueS(seq<seq<boolean>> s)
   = (\forall int i;0<=i && i<|s|;
       (\forall int j;0<=j && j<|s|; (s[i] == s[j]) ==> i == j));
       
  pure boolean has_false_in_prefix(seq<boolean> s,int k)
   = (\exists int y;0<=y && y < k+1 && y<|s|; s[y]==false);
  
  ensures left != right ==> (prefix + left != prefix + right);
  void lemma_uniqueness_prefix(seq<boolean> left, seq<boolean> right, seq<boolean> prefix) {
    if (|left| == |right|) {
      int i = 0;

      loop_invariant 0 <= i && i <= |left|;
      loop_invariant (\forall int j = 0..i; left[j] == right[j]);
      for(; i < |left| && left[i] == right[i]; i++) {

      }

      if(i == |left|) {
        assert left == right;
      } else {
        assert (prefix+left)[i + |prefix|] != (prefix+right)[i + |prefix|];
      }
    } else {
      assert |prefix + left| != |prefix + right|;
    }
  }
  
  requires l <= k && 0 <= l;
  requires (\forall int z;0<=z && z < |last|; 0<=l && l < |last[z]|);
  requires (\forall int z;0<=z && z < |last|;last[z][l]==false);
  ensures (\forall int z;0<=z && z < |last|;has_false_in_prefix(last[z],k));
  void lemma_existence_of_l (seq<seq <boolean>> last,int k,int l) {
    par exf (int z=0..|last|)
      requires 0<=l && l<|last[z]| && last[z][l]==false && l<=k && 0 <= l;
      ensures has_false_in_prefix(last[z],k);
    { 
    }
  }
  
  requires uniqueS(res);
  requires 0 <= j;
  requires j < |res|;
  ensures (\forall int y;0 <= y && y < j;!(prefix + res[y] == prefix + res[j]));
  void lemma_uniqueness_implies_unequal(seq<seq<boolean>> res,int j,seq<boolean> prefix){
    assert (\forall int y;0 <= y && y < j;!(res[y] == res[j]));
    par lemma_uiu_par (int y=0..j)
      requires j<|res| && y<|res| && !(res[y] == res[j]);
      ensures j<|res| && y<|res| && !(prefix + res[y] == prefix + res[j]);
    {
      lemma_uniqueness_prefix(res[y],res[j],prefix);
    }
    return;
  }
  
  requires uniqueS(ini);
  requires (\forall int y;0 <= y && y < |ini|;!(ini[y] == elm));
  ensures uniqueS(ini + seq<seq<boolean>> { elm });
  void lemma_unique_add_one(seq<seq<boolean>> ini, seq<boolean> elm)
  { 
    seq<seq<boolean>> res = ini + seq<seq<boolean>> { elm };
    par lemma_uiu_par (int z=0..|ini|+1)
      context res == ini + seq<seq<boolean>> { elm } && |res| == |ini| + 1;
      requires 0<=z && z<|ini| && (ini[z] == elm) ==> z == |ini|;
      requires (\forall int y;0 <= y && y < |ini|;(ini[y] == res[z])==>y==z);
      ensures (\forall int y;0 <= y && y < |res|;(res[y] == res[z])==>y==z);
    {}
    return;
  }
  
  requires (\forall int y;0<=y && y < |s|;has_false_in_prefix(s[y],k));
  context_everywhere k2 > k;
  ensures (\forall int y;0<=y && y < |s|;has_false_in_prefix(s[y],k2));
  void lemma_has_false_in_prefix_mono(seq<seq<boolean>> s,int k,int k2){
    par lemma_hfip_par (int y=0..|s|)
      requires has_false_in_prefix(s[y],k);
      ensures has_false_in_prefix(s[y],k2); {}
  }

  given seq <boolean> testPresence; // can be any sequence
  requires i>3;
  int countSequences(int i){
    int[] count = new int[i];
    seq<seq<seq <boolean>>> res = seq<seq<seq <boolean>>> {};
    count[0]=1;
    res = res + seq<seq<seq <boolean>>> { seq<seq <boolean>> { seq <boolean> { } } }; // []
    count[1]=1;
    res = res + seq<seq<seq <boolean>>> { seq<seq <boolean>> { seq <boolean> { false } } }; // [B]
    count[2]=1;
    res = res + seq<seq<seq <boolean>>> { seq<seq <boolean>> { seq <boolean> { false, false } } }; // [BB]
    count[3]=2;
    res = res + seq<seq<seq <boolean>>> { seq<seq <boolean>> { seq <boolean> { false, false, false } , seq <boolean> { true, true, true } } }; // [BBB] and [RRR]
    assert (|res[0]| == count[0]);
    assert (|res[1]| == count[1]);
    assert (|res[2]| == count[2]);
    assert (|res[3]| == count[3]);
    assert uniqueS(res[0]);
    assert uniqueS(res[1]);
    assert uniqueS(res[2]);
    assert !(res[3][0][0] == res[3][1][0]);
    assert uniqueS(res[3]);
    
    int n=4;
    loop_invariant n>=4 && n<=i;
    loop_invariant |res| == n;
    loop_invariant (\forall* int j;0<=j && j<i;Perm(count[j],write));
    loop_invariant (\forall int j;0<=j && j<n;|res[j]| == count[j]);
    loop_invariant (\forall int z=0..n, int y=0..|res[z]|; validSequence(res[z][y],z)); // all sequences valid
    loop_invariant (\forall int z;0<=z && z<n;uniqueS(res[z])); // all sequences uniqueS
    while(n<i){
      seq<seq <boolean>> last = seq<seq <boolean>> {};
      count[n] = count[n-1];
      int j = 0;
      loop_invariant |last| == j;
      loop_invariant 0 <= j && j <= |res[n-1]|;
      loop_invariant (\forall* int z;0<=z && z<i;Perm(count[z],write));
      loop_invariant (\forall int z;0<=z && z<n;|res[z]| == count[z]);
      loop_invariant count[n] == count[n-1];
      loop_invariant (\forall int y; 0<=y && y <j; validSequence(last[y],n));
      loop_invariant (\forall int z;0<=z && z <j;|last[z]|>0);
      loop_invariant (\forall int z;0<=z && z <j;last[z][0]==false);
      loop_invariant (\forall int z;0<=z && z<|res|;uniqueS(res[z]));
      loop_invariant (\let int predN = n - 1; (\forall int z;0<=z && z<j;(last[z] == seq <boolean> {false} + res[predN][z])));
      loop_invariant (\forall int z;0<=z && z<j;last[z][0]==false);
      loop_invariant uniqueS(last);
      while (j < |res[n-1]|){
        lemma_uniqueness_implies_unequal(res[n - 1],j,seq <boolean> {false});
        assert (\let int predN = n - 1;
            (\forall int y; 0 <= y && y < |last|; !(seq<boolean>{ false } + res[predN][y] == seq<boolean>{ false } + res[predN][j]))
            );
        last = last + seq<seq<boolean>>{ seq<boolean>{ false } + res[n - 1][j] };
        j = j + 1;
      }
      int k = 3;
      lemma_existence_of_l(last,k-1,0);
      seq <boolean> startBlock = seq <boolean> {true,true,true};
      loop_invariant k>=3 && k<=n && k==|startBlock|;
      loop_invariant (\forall* int j;0<=j && j<i;Perm(count[j],write));
      loop_invariant (\forall int z;0<=z && z<n;|res[z]| == count[z]);
      loop_invariant |last| == count[n];
      loop_invariant (\forall int y;0<=y && y <|last|;validSequence(last[y],n));
      loop_invariant (\forall int y;0<=y && y <|startBlock|;startBlock[y]);
      loop_invariant (\forall int z;0<=z && z <|last|;has_false_in_prefix(last[z],k-1));
      loop_invariant uniqueS(last);
      while(k < n){
        int j = 0;
        seq<seq <boolean>> nxtblock = seq<seq <boolean>> {};
        int countn = count[n];
        loop_invariant 0 <= j && j <= |res[n-k-1]|;
        loop_invariant (\forall* int z;0<=z && z<i;Perm(count[z],write));
        loop_invariant (\forall int z;0<=z && z<n;|res[z]| == count[z]);
        loop_invariant |nxtblock| == j;
        loop_invariant count[n] == countn;
        loop_invariant (\forall int y;0<=y && y <j;validSequence(nxtblock[y],n));
        loop_invariant k>=3 && k ==|startBlock|;
        loop_invariant (\forall int y;0<=y && y <k;startBlock[y]);
        loop_invariant (\forall int y;0<=y && y <j;!has_false_in_prefix(nxtblock[y],k-1)); // li176
        loop_invariant (\forall int y;0<=y && y <j;has_false_in_prefix(nxtblock[y],k));  // li177
        loop_invariant (\forall int y;0<=y && y <j;nxtblock[y] == (startBlock+seq <boolean> {false}) + res[n-k-1][y]);
        loop_invariant uniqueS(nxtblock);
        while (j < |res[n-k-1]|){
          seq<boolean> nxtelm = (startBlock + seq <boolean> {false}) + res[n-k-1][j];
          lemma_uniqueness_implies_unequal(res[n-k-1],j,startBlock + seq <boolean> {false});
          assert !nxtelm[k];
          assert has_false_in_prefix(nxtelm,k);
          lemma_unique_add_one(nxtblock,nxtelm);
          nxtblock = nxtblock + seq<seq <boolean>> { nxtelm };
          assert (\forall int y; 0 <= y && y < |nxtblock|; (nxtblock[y] == nxtelm) ==> y == |nxtblock| - 1);
          j = j + 1;
        }
        count[n] = count[n]+count[n-k-1];
        assert (\forall int z;0<=z && z <|last|;has_false_in_prefix(last[z],k));
        last = last + nxtblock;
        assert |last| == count[n];
        k = k + 1;
        startBlock = startBlock + seq <boolean> {true};
      }
      assert |last| == count[n]; // not needed, shows intention
      last = last + seq<seq <boolean>> { startBlock };
      count[n] = count[n]+1;
      n = n + 1;
      res = res + seq<seq<seq <boolean>>> { last } ;
    }
    
    assert |res[i-1]| == count[i-1]; // algorithm computed the number corresponding to our ghost variable
    assert (\let int predI = i - 1;
        (\forall int y; 0<=y && y <|res[i-1]|;validSequence(res[predI][y],i-1)) // all sequences are valid
        );
    assert uniqueS(res[i-1]); // all sequences are uniqueS
    return count[i-1];
  }
  
}